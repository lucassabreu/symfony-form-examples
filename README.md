Symfony Forms
=============

> ‚ÑπÔ∏è  Esse reposit√≥rio foi criado para acompanhar essa apresenta√ß√£o para um time interno

O pacote [`symfony/form`][symfony-form] √© um componente do [Symfony][] para trabalhar com formul√°rios HTML,
seja a gera√ß√£o de HTML ou a valida√ß√£o/processamento dos mesmos num servidor.

Nesse reposit√≥rio vou explorar mais o uso desse componente para valida√ß√£o num servidor funcionando como
[BFF][] para um frontend que n√£o necessariamente √© provido pelo servidor processamento esses formul√°rios.

Roteiro:
- Conceitos
- Exemplo b√°sico
- Valida√ß√£o de entradas
- Formul√°rios reutiliz√°veis
  - Passando par√¢metros para tipos
  - Resultado customizado
- Transforma√ß√µes
- Truques para BFF

Conceitos
---------

O Symfony Forms permite que montemos formul√°rios HTML a partir de um objeto PHP, e com isso validarmos se o
mesmo foi enviado, se os dados enviados s√£o v√°lidos e completos, injetar os mesmos diretamente num objeto PHP
ou vetor, e se for usado junto ao pacote de [Twig][twig-bundle] permite gerar o HTML para o formul√°rio da
defini√ß√£o citada.

Dessa forma um formul√°rio do Symfony teria tr√™s etapas principais: constru√ß√£o, processamento e renderiza√ß√£o.

A constru√ß√£o do formul√°rio pode ser feita direto num Controller/Action ou a partir de [classes
`FormType`][formulario-reutilizavel]. Nas duas situa√ß√µes usamos o [`FormFactory`][form-factory] e precisamos
definir quais os campos que esperamos no formul√°rio, assim como seus tipos e opcionalmente [como
valid√°-los][validacao-entradas] e [transform√°-los][transformacoes].

Por padr√£o um formul√°rio do Symfony tamb√©m precisar√° de nome que ser√° usado para diferenciar m√∫ltiplos
formul√°rios numa mesma chamada, assim como controles como CSRF. Esse nome ser√° usado como prefixo para todos
os campos do formul√°rio, se definir a entrada `idade` e o nome do formul√°rio for `pessoa`, ent√£o ele espera um
campo `pessoa[idade]` no corpo da requisi√ß√£o.

> üí° Existem formas de contornar a necessidade do prefixo nas chamadas, visto que t√™-lo n√£o √© interessantes
> pensando em uma API, como fazer isso ser√° explorado em [Truques para BFF][truques-bff]

O processamento √© feito chamando o m√©todo `handleRequest` de um formul√°rio, o mesmo ir√° interpretar a
requisi√ß√£o e verificar se teve o envio do formul√°rio, e feito isso podemos usar os m√©todos `isSubmitted` e
`isValid` para validar a requisi√ß√£o.

- Se tudo estiver certo no formul√°rio o `isValid` ir√° retornar `true` e podemos chamar o `getData` do mesmo
  para pegar os dados tratados.
- Se o formul√°rio n√£o tiver sido enviado, o `isSubmitted` ir√° retornar  `false` e o `getData` n√£o ser√°
  confi√°vel e nenhuma validac√£o ser√° feita sobre os dados.
- Se o formul√°rio foi enviado, mas houverem problemas com as informa√ß√µes, ent√£o o `isValid` ir√° retornar
  `false` e os erros estar√£o dispon√≠veis no m√©todos `getErrors`

Exemplo b√°sico
--------------

Para termos um exemplo, vamos criar um formul√°rio para receber "tarefas", onde uma tarefa ter√° um nome
(`name`) e um previs√£o de entrega (`dueDate`), um Controller com esse formul√°rio ficaria:

```php
class Controller
{
    public function __invoke(
        Request $request,
        FormFactoryInterface $formFactory,
        Environment $twig,
    ): Response {
        /** @var FormInterface */
        $form = $formFactory->createBuilder()
            ->add('name', TextType::class)
            ->add('dueDate', DateType::class, ['widget' => 'single_text'])
            ->add('save', SubmitType::class)
            ->getForm();

        $form->handleRequest($request);
        if ($form->isSubmitted() && $form->isValid()) {
            return new JsonResponse($form->getData());
        }

        return new Response($twig->render('form.html.twig', [
            'form' => $form->createView(),
        ]));
    }
}
```

No c√≥digo acima estamos usando o `FormFactory` para montar o formul√°rio, usamos o `handleRequest` para
processar a requisi√ß√£o, caso esteja v√°lida estamos retornando os dados v√°lidos como um JSON, se n√£o estiverem,
ou n√£o tiverem sido enviados, ent√£o mostramos o formul√°rio em HTML.

O arquivo `form.html.twig` tem o seguinte conte√∫do:
```twig
{% extends "base.html.twig" %}
{% block body %} {{ form(form) }} {% endblock %}
```

Se nada for informado o formul√°rio abaixo:

![formul√°rio renderizado](./assets/first-form.png)

Todos os tipos de `input` padr√µes do HTML5 s√£o suportados, pode velos aqui:
https://symfony.com/doc/current/reference/forms/types.html

Outros tipos mais voltados para problemas e valores usados em aplica√ß√µes tamb√©m est√£o dispon√≠veis, como
UuidType, BirthdayType e EnumType.

Valida√ß√£o de Entradas
---------------------

At√© agora podemos definir os campos que existem no formul√°rio e o tipo dos mesmos, mas se chamarmos o endpoint
apenas com o campo `form[name]` sem passar o `form[dueDate]`, ou o contr√°rio, o Symfony intende que a
requisi√ß√£o √© v√°lida, e vai preencher o os outros campos com o valor padr√£o.

Para podermos de fato validar os valores enviados vamos adicionar o pacote [Validator](symfony-validator) do
Symfony (`symfony/validator`). Existe uma variedade de validadores dispon√≠veis, para aplic√°-los usaremos o
terceiro par√¢metro do `FormType::add`, alterando o exemplo anterior para obrigar a passar os dois campos:

```php
use Symfony\Component\Validator\Constraints\NotBlank;
// ...
$form = $formFactory->createBuilder()
    ->add('name', TextType::class, ['constraints' => [
        new NotBlank(),
    ]])
    ->add('dueDate', DateType::class, ['widget' => 'single_text', 'constraints' => [
        new NotBlank(),
    ]])
    ->add('save', SubmitType::class)
    ->getForm();
// ...
```

Agora os dois campos passam a ser obrigat√≥rios, se n√£o passarmos o `$form->getErrors()` vai ser alimentado, e
se renderizarmos o formul√°rio em HTML as mensagens ir√£o aparecer como abaixo:

![formul√°rio com mensagens de erro](./assets/form-with-error.png)

Podemos fazer outras valida√ß√µes mais interessantes como se o valor informado √© um n√∫mero de cart√£o de cr√©dito
v√°lido usando o [`Luhn`][val-luhn], ou se √© um [`IP`][val-ip] v√°lido.

Existem outras valida√ß√µes mais simples, se um valor est√° numa faixa, se tem alguns n itens, se √© UUID, etc.
Que podem ser usadas para em combina√ß√µes com tipos de entrada espec√≠ficas para ter valida√ß√µes melhores.

Voltando para o exemplo original, vamos agora adicionar que o nome da tarefa precisa ter 5 caracteres ou mais,
e que a data prevista √© opcional, mas que precisa ser hoje ou no futuro:

```php
use Symfony\Component\Validator\Constraints\GreaterThanOrEqual;
use Symfony\Component\Validator\Constraints\Length;
// ...
$form = $formFactory->createBuilder()
    ->add('name', TextType::class, ['constraints' => [
        new NotBlank(),
        new Length(min: 5),
    ]])
    ->add('dueDate', DateType::class, ['widget' => 'single_text', 'constraints' => [
        new GreaterThanOrEqual(new \DateTime('today'), message: 'Due Date can not be in the past'),
    ]])
    ->add('save', SubmitType::class)
    ->getForm();
// ...
```

Se tentarmos informar errado iremos receber:

![form with new errors](./assets/form-with-new-errors.png)

Infelizmente as valida√ß√µes acima v√£o ser aplicadas apenas no processamento do formul√°rio no backend, ou seja,
a vers√£o renderizada do formul√°rio n√£o ir√° adicionar os atributos equivalentes para que o navegador trate,
para isso temos de adicion√°-los "manualmente" usando a op√ß√£o `attr` ao adicion√°-los, para que o `name`
valide que tem mais de 5 caracteres ficaria:
```php
    ->add('name', TextType::class, [
        'attr' => ['minlength' => 5],
        'constraints' => [new NotBlank(), new Length(min: 5)],
    ])
```

Formul√°rios reutiliz√°veis
-------------------------

Algo comum em quase todo sistema ser√° que alguns endpoints ter√£o entradas similares ou ir√£o ter campos que tem
o mesmo proposito ou valida√ß√£o entre eles. Para tratar essas situa√ß√µes podemos mover a defini√ß√£o de um
formul√°rio para uma classe dedicada que ir√° montar os formul√°rios/adicionar valida√ß√µes e os Controllers e
outros formul√°rios podem simplesmente referenci√°-las.

Vamos dizer que queremos aproveitar a defini√ß√£o do formul√°rio de tarefas que temos hoje, para isso vamos criar
uma nova classe que estende [`AbstractType`][abst-type], essa classe ser√° como abaixo:

```php
<?php

namespace App\Controller\Reusing;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\DateType;
use Symfony\Component\Form\Extension\Core\Type\SubmitType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\Validator\Constraints\GreaterThanOrEqual;
use Symfony\Component\Validator\Constraints\Length;
use Symfony\Component\Validator\Constraints\NotBlank;

class TaskType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('name', TextType::class, ['constraints' => [
                new NotBlank(),
                new Length(min: 5),
            ]])
            ->add('dueDate', DateType::class, [
                'widget' => 'single_text',
                'required' => false,
                'constraints' => [new GreaterThanOrEqual(
                    new \DateTime('today'),
                    message: 'Due Date can not be in the past'
                )],
            ])
            ->add('save', SubmitType::class);
    }
}
```

E agora podemos criar um `UpdateTaskType` que "estende" `TaskType`, mas pede o `ID` da tarefa para
atualizar. Esse novo `Type` fica assim:

```php
<?php

namespace App\Controller\Reusing;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\IntegerType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\Validator\Constraints\NotBlank;

class UpdateTaskType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
        $builder
            ->add('id', IntegerType::class, [
                'priority' => 1, // just to put it into the top
                'constraints' => [new NotBlank()],
            ]);
    }

    public function getParent(): string
    {
        return TaskType::class;
    }
}
```

No Controller vamos fazer uma altera√ß√£o para usar o `UpdateTaskType` no lugar de montar no m√©todo, no final
tudo fica igual exceto a montagem:
```php
class Controller implements ControllerInterface
{
    public function __invoke(/** ... */): Response {
        /** @var FormInterface */
        $form = $formFactory->createNamedBuilder('form', UpdateTaskType::class)
            ->getForm();

        $form->handleRequest($request);
        if ($form->isSubmitted() && $form->isValid()) {
            return new JsonResponse($form->getData());
        }
        // ...
```

O `createNamedBuilder` funcional igual ao `createBuilder`, exceto que ele permite dar um nome para o
formul√°rio no lugar de deixar o nome definido no `Type` ou o autogerado.

O resultado disso √© como abaixo:

![extended form](./assets/extend-form.png)

Vamos dizer que agora queremos poder vincular qual √© o usu√°rio respons√°vel pela tarefa assim como quem s√£o as
pessoas interessadas na tarefa. Esses dois s√£o informados passando o nome de usu√°rio, e vamos precisar validar
que √© um usu√°rio v√°lido, a regra ser√° que aceita apenas letras minusculas e n√∫meros.

Para isso vamos criar um `Type` chamado `UsernameType` para fazer essa valida√ß√£o:
```php
<?php

namespace App\Controller\Reusing;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\TextType;
use Symfony\Component\OptionsResolver\OptionsResolver;
use Symfony\Component\Validator\Constraints\Length;
use Symfony\Component\Validator\Constraints\Regex;

class UsernameType extends AbstractType
{
    public function getParent(): string
    {
        return TextType::class;
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefault('constraints', [
            new Length(min: 5),
            new Regex(
                '/^[a-z0-9]+$/',
                message: 'Username must constain only letters and numbers'
            ),
        ]);
    }
}
```

Feito isso podemos adicionar no `TaskType` da seguinte forma:
```php
            ->add('assignee', UsernameType::class)
            ->add('stackholders', CollectionType::class, [
                'entry_type' => UsernameType::class,
                'allow_add' => true,
                'allow_delete' => true,
            ])
```

Agora se renderizamos esse formul√°rio e tentar informar valores incorretos teremos a seguinte imagem:

![form with assignee and stackholders](./assets/form-with-assignee.png)

Como nesse formul√°rio tivemos um campo que se repete usamos o [`CollectionType`][coll-type] que √© a forma como
o Symfony permite adicionar cole√ß√µes de objetos, aqui estamos usando apenas um valor, mas poderia ser um
`FormType` mais complexo como uma vers√£o do `TaskType`.

### Resultados customizados

Podendo montar formul√°rios, criar tipos customizados e reutilizar esses formul√°rios podemos explorar uma
funcionalidade muito importante do Symfony Forms, que √© poder informar uma classe de dados (`data_class`) para
ele alimentar no lugar de retornar um vetor.

Para uma classe poder ser usada como `data_class` duas coisas s√£o necess√°rias:
- a classe n√£o pode ter argumentos obrigat√≥rios no construtor
- todos as propriedades que forem alimentados pelo `FormType` precisam ser p√∫blicas, ou terem um "setter"
  p√∫blico.

Quase qualquer classe consegue atender esses requisitos, mas a minha recomenda√ß√£o seria que sejam usados
[DTOs][dto] no lugar de entidades, primeiro porque esse tipo de objeto √© pensando para isso, e evita que o
estado das entidades fique inv√°lido, mesmo que temporariamente, enquanto o Symfony Forms est√° alimentando e
validando os campos.

Um DTO que poderia ser usado para o `UpdateTaskType` que temos agora seria assim:

```php
<?php

namespace App\Controller\DataClass;

class TaskDTO
{
    private int $id;
    private string $name;
    private ?\DateTime $dueDate = null;
    private string $assignee;
    /** @var string[] */
    private array $stackholders = [];

    public function setId(int $id): void
    {
        $this->id = $id;
    }

    public function setName(string $name): void
    {
        $this->name = $name;
    }

    public function setDueDate(?\DateTime $dueDate): void
    {
        $this->dueDate = $dueDate;
    }

    public function setAssignee(string $assignee): void
    {
        $this->assignee = $assignee;
    }

    /** @param string[] $stackholders */
    public function setStackholders(array $stackholders): void
    {
        $this->stackholders = $stackholders;
    }

    // getters
}
```

Para o Symfony Forms usar esse DTO basta adicionar o m√©todo `configureOptions` e configurar o campo
`data_class`, como abaixo:

```php
    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefault('data_class', TaskDTO::class);
    }
```

[val-host]: https://symfony.com/doc/current/reference/constraints/Hostname.html
[val-luhn]: https://symfony.com/doc/current/reference/constraints/Luhn.html
[val-ip]: https://symfony.com/doc/current/reference/constraints/Ip.html
[symfony-form]: https://symfony.com/doc/current/forms.html
[Symfony]: https://symfony.com/
[BFF]: https://samnewman.io/patterns/architectural/bff/
[form-factory]: https://github.com/symfony/form/blob/0a1a3ea071a216e2902cebe0b47750ca51f12f27/FormFactory.php#L17
[abst-type]: https://github.com/symfony/symfony/blob/8084eb83a44a3639a95f0860456d737b7f2751dd/src/Symfony/Component/Form/AbstractType.php#L21
[formulario-reutilizavel]: #formul√°rios-reutiliz√°veis
[truques-bff]: #
[twig-bundle]: https://symfony.com/components/Twig%20Bundle
[validacao-entradas]: #valida√ß√£o-de-entradas
[transformacoes]: #
[symfony-validator]: https://symfony.com/doc/current/validation.html
[coll-type]: https://symfony.com/doc/current/reference/forms/types/collection.html

<!-- vim: textwidth=110 colorcolumn=111
